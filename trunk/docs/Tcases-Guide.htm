<HTML>
  <HEAD>
    <LINK rel="stylesheet" type="text/css" href="tcases.css"/>
    <TITLE>Tcases: The Complete Guide</TITLE>
  </HEAD>
  <BODY>

    <DIV class="page">
      <H1>Tcases: The Complete Guide</H1>

      <H2>Contents</H2>
      <UL>
        <LI> <A href="#intro"> Introduction </A>
          <UL>
            <LI><A href="#what">What Does It Do?</A></LI>     
            <LI><A href="#how">How Does It Work?</A></LI> 
            <LI><A href="#why">Why Tcases?</A></LI>      
          </UL>
        </LI>
        <LI> <A href="#start"> Getting Started </A>
          <UL>
            <LI><A href="#install">Installing Tcases</A></LI>     
            <LI><A href="#run">Running From the Command Line</A></LI> 
            <LI><A href="#run-ant">Running With Ant</A></LI>      
            <LI><A href="#results">Understanding Tcases Results</A></LI>      
          </UL>
        </LI>
        <LI><A href="#input">Modeling The Input Space</A>
          <UL>
            <LI><A href="#exampleFind">An Example: The find Command</A></LI> 
            <LI><A href="#functions">Defining System Functions</A></LI> 
            <LI><A href="#vars">Defining Input Variables</A></LI>
            <LI><A href="#values">Defining Input Values</A></LI>
            <LI><A href="#varSets">Defining Variable Sets</A></LI>
            <LI><A href="#constraints">Defining Constraints: Properties and Conditions</A></LI>
          </UL>
        </LI>
        <LI><A href="#coverage">Defining Input Coverage</A></LI>
        <LI><A href="#control">Controlling Test Cases</A></LI>
        <LI><A href="#transform">Transforming Test Cases</A>
          <UL>
            <LI><A href="#junit">Creating JUnit Tests</A></LI>
          </UL>
        </LI>
      </UL>

      <H2><A name="intro">Introduction</A></H2>
      <H3><A name="what">What Does It Do?</A></H3>     
      <P>
        Tcases is a tool for designing tests. It doesn't matter what kind of system you are
        testing. Nor does it matter what level of the system you are testing &mdash; unit, subsystem,
        or full system. You can use Tcases to design your tests in any of these situations. With
        Tcases, you define the input space for your system-under-test and the level of coverage that
        you want. Then Tcases generates a minimal set of test cases that meets your requirements.
      </P>
      <P>
        Tcases is primarily a tool
        for <A href="http://en.wikipedia.org/wiki/Black-box_testing">black-box test design</A>. For
        such tests, the concept of "coverage" is different from structural testing critieria such as
        line coverage, branch converage, etc. Instead, Tcases is guided by coverage of the input
        space of your system.  
      </P>
      <P>
        What is the "input space" of the system? The simplest way to look at
        it is this: the set of all (combinations of) input values that could possibly be
        applied. Easy to say, but hard to do! For all but the simplest systems, such a set is
        enormous, perhaps even infinite. You could never afford to build and run all those test
        cases.  Instead, you have to select test cases from a small sample of the input space. But
        how? If your sample is too big, you'll run out of time before you finish. But if your
        sample is too small &mdash; or, worse, if it's the <EM>wrong</EM> subset &mdash; you'll miss lots
        of defects. 
      </P>
      <P>
        That is the test design problem: given a limited amount of testing effort, how can you
        minimize the risk of defects?  And Tcases is the tool for the job. Tcases gives you a way to
        define the input space for your system in a form that is concise but comprehensive.  Then Tcases
        allows you to control the number of test cases in your sample subset by specifying the level
        of coverage you want. You can start with a basic level of coverage, and Tcases will generate
        a small set of test cases that touches every significant element of the input space. Then
        you can improve your tests by selectively adding coverage in specific high-risk areas.  For
        example, you can specify <A href="http://en.wikipedia.org/wiki/All-pairs_testing">pairwise
        coverage</A> or higher-order combinations of selected input variables.
      </P>


      <H3><A name="how">How Does It Work?</A></H3> 
      <P>
        First, you create a <A href="#systemInputDef">system input definition</A>, an XML document
        that defines your system as a set of <A href="#functionInputDef">functions</A>. For each
        system function, the system input definition defines the <A href="#varDef">variables</A>
        that characterize the function input space.
      </P> 
      <P>
        Then, you can create a <A href="#genDef">generator definition</A>. That's another XML
        document that defines the coverage you want for each system function. The generator
        definition is optional. You can skip this step and still get a basic level of coverage.
      </P>
      <P>
        Finally, you run Tcases. Tcases is a Java program that you can run from the command line or
        from your favorite IDE.  Tcases comes with built-in support for running using
        a <SPAN class="code">bash</SPAN> shell script or an <SPAN class="code">ant</SPAN> target.
        Using your input definition and your generator definition, Tcases generates
        a <A href="#systemTestDef">system test definition</A>.  The system test definition is an XML
        document that lists, for each system function, a set of test cases that provides the
        specified level of coverage. Each test case defines a specific value for every function
        input variable. Tcases generates not only valid input values that define successful test
        cases but also invalid values for the tests cases that are needed to verify expected error
        handling.
      </P>
      <P>
        Of course, the system test definition is not something you can execute directly. But it
        follows a well-defined XML schema, which means you can use a variety of XML transformation tools to
        convert it into a form that it suitable for testing your system. For example, Tcases comes with a
        built-in transformer that converts a system test definition into a Java source code template
        for a JUnit test class.
        
      </P>

      <H3><A name="why">Why Tcases?</A></H3>      
      <P>
        <UL>
          <LI><B>If you are defining acceptance for a new story...</B>
            <P>
              Tcases gives you a powerful technique for crystallizing your understanding of a new story: 
              <A href="#input">modeling the input space</A>. This is especially helpful if you are following a
              <A href="http://en.wikipedia.org/wiki/Behavior_Driven_Development">behavior-driven
              development (BDD)</A> process. BDD captures the intended system behavior using a few
              key examples, each of which is expressed in the form of a test case. BDD examples
              naturally identify important system input variables.  Input modeling then leads to a
              deeper and broader understanding of the inputs that the system must handle. Quickly
              creating a high-level <A href="#input">system input definition</A> is great way to
              check if you've identified all the examples you need.
            </P>
          </LI>
          <P/>
          <LI><B>If you are building unit tests...</B>
            <P>
              Tcases is a crucial complement to
              the <A href="http://en.wikipedia.org/wiki/Test-Driven_Development">test-driven
              development (TDD)</A> approach to building unit tests.
              <P>(TBD)<P>
            </P>
          </LI>
          <P/>
          <LI><B>If you are building system tests...</B>
            <P>
              <P>(TBD)<P>
            </P>
          </LI>
          <P/>
        </UL>
      </P>

      <H2><A name="start">Getting Started</A></H2>
      <H3><A name="install">Installing Tcases</A></H3>
      <P>
        Your first move is to download the Tcases binary distribution file. You can choose to
        download this in either of two different forms: a ZIP file or a compressed (<SPAN class="code">gzip</SPAN>)
        <SPAN class="code">tar</SPAN> file. Extract the contents of the distribution file to any
        directory you like &mdash; this is now your <EM>"Tcases home directory"</EM>. Unpacking the distribution file will
        create a <EM>"Tcases release directory"</EM> &mdash; a subdirectory of the
        form <SPAN class="code">tcases-<I>m</I>.<I>n</I>.<I>r</I></SPAN> &mdash; that contains all
        the files for this release of Tcases. The release directory contains the following subdirectories.
      </P>

      <UL>
        <LI> <SPAN class="code">bin</SPAN>: Executable shell scripts used to run Tcases </LI><P/>
        <LI> <SPAN class="code">docs</SPAN>: User guide, examples, and Javadoc </LI><P/>
        <LI> <SPAN class="code">lib</SPAN>: All JAR files needed to run Tcases </LI><P/>
      </UL>

      <P>
        One more step and you're ready to go: add the path to the <SPAN class="code">bin</SPAN> subdirectory to the
        <SPAN class="code">PATH</SPAN> environment variable for your system.
      </P>

      <H3><A name="run">Running From the Command Line</A></H3>
      <P>
        You can run Tcases directly from your shell command line. If you use <SPAN class="code">bash</SPAN> or a similar
        UNIX shell, you can run the <SPAN class="code">tcases.sh</SPAN> command.
        For a quick check, you can run one of the examples that comes with Tcases, using the following commands.

        <DIV class="exampleCode">
          &gt; cd <I>&lt;tcases-release-dir&gt;</I> <BR/>
          &gt; cd docs/examples <BR/>
          &gt; tcases.sh &lt; find-Input.xml <BR/>
        </DIV>
      </P>
      <P>
        For details about the interface to the <SPAN class="code">tcases.sh</SPAN> command, see the
        Javadoc
        for the <A href="api/com/startingblocktech/tcases/Tcases.Options.html"><SPAN class="code">Tcases.Options</SPAN></A> class.
        To get help at the command line, run <SPAN class="code">tcases.sh -help</SPAN>.
      </P>

      <H3><A name="run-ant">Running With Ant</A></H3>
      <P>
        You can also run Tcases as an Ant task. For an example of how this works, take a look at <SPAN class="code">docs/examples/ant-tcases.xml</SPAN>.
        Want to try it out? Run the the following commands.
        
        <DIV class="exampleCode">
          &gt; cd <I>&lt;tcases-release-dir&gt;</I> <BR/>
          &gt; cd docs/examples <BR/>
          &gt; ant -f ant-tcases.xml <BR/>
        </DIV>

      </P>
      <P>
        For details about the interface to the <SPAN class="code">tcases</SPAN> task, see the
        Javadoc
        for the <A href="api/com/startingblocktech/tcases/ant/TcasesTask.html"><SPAN class="code">TcasesTask</SPAN></A> class.
      </P>
      
      <H3><A name="results">Understanding Tcases Results</A></H3>
      <P>
        What happens when you run Tcases? Tcases reads a <A href="#systemInputDef">system input definition</A>, an XML document
        that defines the "input space" of the system function to be tested. From this, Tcases produces a different XML document
        called a <A href="#systemTestDef">system test definition</A>, which describes a set of test cases.
      </P>

      <P>
        Try running Tcases on one of the example system input definitions. The following commands will generate
        test cases for the <SPAN class="code">find</SPAN> command <A href="#exampleFind">example</A>, which is
        explained in <A href="#input">full detail</A> later in this guide.

        <DIV class="exampleCode">
          &gt; cd <I>&lt;tcases-release-dir&gt;</I> <BR/>
          &gt; cd docs/examples <BR/>
          &gt; tcases.sh &lt; find-Input.xml <BR/>
        </DIV>
      </P>

      <P>
        The resulting system test definition is written to standard output. Here's what it looks like: for
        the "find" <A href="#functions">function</A>, a list of test case definitions, each of which defines values for all of
        the function's input <A href="#vars">variables</A>.

        <DIV class="exampleDoc">
          &lt;?xml version="1.0"?&gt; <BR/>
          &lt;TestCases system="Examples"&gt; <BR/>
          &nbsp; &lt;<SPAN class="exampleEmph">Function</SPAN> name="find"&gt; <BR/>
          &nbsp; &nbsp; &lt;<SPAN class="exampleEmph">TestCase</SPAN> id="0"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;Input type="arg"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;<SPAN class="exampleEmph">Var</SPAN> name="pattern.size" <SPAN class="exampleEmph">value</SPAN>="empty"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="pattern.quoted" value="yes"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="pattern.blanks" value="NA"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="pattern.embeddedQuotes" value="NA"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="fileName" value="defined"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;/Input&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;Input type="env"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="file.exists" value="yes"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="file.contents.linesLongerThanPattern" value="one"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="file.contents.patterns" value="NA"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="file.contents.patternsInLine" value="NA"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;/Input&gt; <BR/>
          &nbsp; &nbsp; &lt;/TestCase&gt; <BR/>
          &nbsp; &nbsp; ... <BR/>
          &nbsp; &lt;/Function&gt; <BR/>
          &lt;/TestCases&gt; <BR/>
        </DIV>
      </P>

      <H2><A name="input">Modeling The Input Space</A></H2>
      <P>
        Tcases creates test definitions based on a <EM>system input definition</EM> that you create. But how
        do you do that? That's what this section aims to explain.
      </P>
      <P>
        A <EM>system input definition</EM> is an XML document that models the
        "input space" of the system-under-test (SUT). We say it "models" system inputs because it doesn't
        literally itemize all possible input values. Instead, a system input definition lists all the
        important aspects of system inputs that affect system results. Think of this as
        describing the "dimensions of variation" in the "input space" of your system. Some dimensions of
        variation are obvious. If you are testing the <SPAN class="code">add</SPAN> function, you know there
        are at least two dimensions of variation &mdash; the two different numbers being added. But to find
        all of the key dimensions, you may have to take a deeper look.
      </P>

      <P>
        For example, consider how you might test a simple "list files" command, like
        the <SPAN class="code">ls</SPAN> command in <SPAN class="code">UNIX</SPAN>. (And to keep it simple,
        let's assume there are no command options or switches to worry about.) Clearly, one dimension of
        variation is the number of file names given. <SPAN class="code">ls</SPAN> should handle not just one
        file name but also a list of many file names. And if no file names are
        given, <SPAN class="code">ls</SPAN> is expected to have a completely different result. But what about each
        file name itself? <SPAN class="code">ls</SPAN> will produce a different result, depending on whether
        this is a relative file name or an absolute path. So, the "relativeness" of the file name is an
        additional dimension of variation. But that's not all! Some file names could identify actual files,
        but others could be bogus names for files that don't exist, and this difference has a big effect of
        what <SPAN class="code">ls</SPAN> is expected to do. So, here's another dimension of variation that
        has nothing to do with the file names themselves but instead concerns the state of the environment in
        which <SPAN class="code">ls</SPAN> runs.
      </P>

      <P>
        You can see that modeling the input space demands careful thought about the SUT. That's a job that no
        tool can do for you. But Tcases gives you a way to capture that knowledge and to translate it into
        effective test cases.
      </P>

      <H3><A name="exampleFind">An Example: The find Command</A></H3>
      <P>
        To understand input modeling with Tcases, it helps to see an example in action. In this guide, we're
        going to explain how Tcases works by showing how we can use it to test a hypothetical <SPAN class="code">find</SPAN>
        command. The complete input definition for <SPAN class="code">find</SPAN> is included with this guide &mdash; you can
        see it <A href="examples/find-Input.xml">here</A>.
      </P>

      <P>
        Take a look at the <SPAN class="code">find</SPAN> specification below. What test cases would you use to test it?
        
        <BLOCKQUOTE>
          Usage: <SPAN class="code">find pattern file</SPAN>
          <BR/><BR/>
          Locates one or more instances of a given pattern in a text file. 
          <BR/><BR/>
          All lines in the file that contain the pattern are written to standard output. A
          line containing the pattern is written only once, regardless of the number of
          times the pattern occurs in it.
          <BR/><BR/>
          The pattern is any sequence of characters whose length does not exceed the
          maximum length of a line in the file. To include a blank in the pattern, the
          entire pattern must be enclosed in quotes (&quot;). To include a quotation mark in the
          pattern, two quotes in a row ("") must be used.
        </BLOCKQUOTE>
      </P>

      <H3><A name="functions">Defining System Functions</A></H3>
      <P>
        A <A name="systemInputDef">system input definition</A> describes a specific system-under-test, so the root element of the document looks like this:

        <DIV class="exampleDoc">
          &lt;System name="<SPAN class="exampleEmph">${mySystemName}</SPAN>"&gt; <BR>
          &nbsp; <SPAN class="exampleComment">&lt;!-- All input definitions go here --&gt;</SPAN> <BR/>
          &lt;/System&gt; <BR/>
        </DIV>

        In general, the SUT has one or more operations or "functions" to be tested. Accordingly,
        the <SPAN class="code">System</SPAN> element contains
        a <A name="functionInputDef"><SPAN class="code">Function</SPAN></A> element for each of them.

        <DIV class="exampleDoc">
          &lt;System name="${mySystemName}"&gt; <BR/>
          &nbsp; &lt;Function name="<SPAN class="exampleEmph">${function-1}</SPAN>"&gt; <BR/>
          &nbsp; &nbsp; <SPAN class="exampleComment">&lt;!-- All input definitions for ${function-1} go here --&gt;</SPAN> <BR/>
          &nbsp; &lt;/Function&gt; <BR/>
          <BR/>
          &nbsp; &lt;Function name="<SPAN class="exampleEmph">${function-2}</SPAN>"&gt; <BR/>
          &nbsp; &nbsp; <SPAN class="exampleComment">&lt;!-- All input definitions for ${function-2} go here --&gt;</SPAN> <BR/>
          &nbsp; &lt;/Function&gt; <BR/>
          &nbsp; ... <BR/>
          &lt;/System&gt; <BR/>
        </DIV>
      </P> 
      
      <P>
        Obviously, what constitutes a "system" or a "function" depends entirely on what you're testing. If your "system" is a Java class, then your
        "functions" might be its methods. If your "system" is an application, then your "functions" might be use cases. If your "system" is a Web site,
        then your "functions" might be pages. In any case, the process of input modeling is exactly the same.
      </P>
      
      <P>
        For our example, we'll build an input definition for a system named "Examples" which has only one function named "find".

        <DIV class="exampleDoc">
          &lt;System name="Examples"&gt; <BR/>
          &nbsp; &lt;Function name="<SPAN class="exampleEmph">find</SPAN>"&gt; <BR/>
          &nbsp; &nbsp; ... <BR/>
          &nbsp; &lt;/Function&gt; <BR/>
          &lt;/System&gt; <BR/>
        </DIV>
      </P>

      <H3><A name="vars">Defining Input Variables</A></H3>
      <P>
        For each function to be tested, you need to define all of the dimensions of variation in its input
        space. For simplicity, Tcases refers to each such dimension as a "variable" and each basic variable is
        represented by a <A name="varDef"><SPAN class="code">Var</SPAN></A> element.  In addition,
        Tcases organizes input variables by type, using an <SPAN class="code">Input</SPAN> element.
      </P>
      <P>
        The <SPAN class="code">find</SPAN> command has two different types of input variables. There are direct input
        arguments, such as the file name, which have input type <SPAN class="code">arg</SPAN>. There are also other factors, such as
        the state of the file, which act as indirect "environmental" input variables and are given input type <SPAN class="code">env</SPAN>.
        (More details about these are shown in a <A href="#exampleEnv">later section</A>.)

        <DIV class="exampleDoc">
          &lt;System name="Examples"&gt; <BR/>
          &nbsp; &lt;Function name="find"&gt; <BR/>
          &nbsp; &nbsp; &lt;Input type="<SPAN class="exampleEmph">arg</SPAN>"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; <SPAN class="exampleComment">&lt;!-- arg: Direct input arguments (the default) --&gt;</SPAN> <BR/>
          &nbsp; &nbsp; &nbsp; &lt;Var name="<SPAN class="exampleEmph">fileName</SPAN>"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; ... <BR/>
          &nbsp; &nbsp; &nbsp; &lt;/Var&gt;<BR/>
          &nbsp; &nbsp; &nbsp; ... <BR/>
          &nbsp; &nbsp; &lt;/Input&gt; <BR/>
          <BR/>
          &nbsp; &nbsp; &lt;Input type="<SPAN class="exampleEmph">env</SPAN>"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; <SPAN class="exampleComment">&lt;!-- env: Environment state variables --&gt;</SPAN> <BR/>
          &nbsp; &nbsp; &nbsp; ... <BR/>
          &nbsp; &nbsp; &lt;/Input&gt; <BR/>
          &nbsp; &nbsp; ... <BR/>
          &nbsp; &lt;/Function&gt; <BR/>
          &lt;/System&gt; <BR/>
        </DIV>
      </P>
      
      <P>
        Actually, the <SPAN class="code">type</SPAN> attribute of the <SPAN class="code">Input</SPAN>
        element is just a tag that can be any value you want. And it is optional &mdash; if omitted, the
        default is <SPAN class="code">arg</SPAN>.  This grouping of inputs by type is available if you find it
        helpful. There is no limit to the number of different <SPAN class="code">Input</SPAN> types that you
        can define.
      </P>

      <H3><A name="values">Defining Input Values</A></H3>
      <P>
        For Tcases to create a test case, it must choose values for all of the input variables. How does it do
        that? Because we describe all of the possible values for each input variable using one or
        more <SPAN class="code">Value</SPAN> elements. 
      </P>
      <P>
        By default, a <SPAN class="code">Value</SPAN> element
        defines a valid value, one that the function-under-test is expected to accept. But we can use the
        optional <SPAN class="code">failure</SPAN> attribute to identify an value that is invalid and expected
        to cause the function to produce some kind of failure response.  Tcases uses these input
        values to generate two types of test cases &mdash; "success" cases, which use only valid values for all
        variables, and "failure" cases, which use a <SPAN class="code">failure</SPAN> value for exactly one
        variable.
      </P>
      <P>
        For example, we can define two possible values for the <SPAN class="code">fileName</SPAN> argument to <SPAN class="code">find</SPAN>.

        <DIV class="exampleDoc">
          &lt;Function name="find"&gt; <BR/>
          &nbsp; &lt;Input type="arg"&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="fileName"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; <SPAN class="exampleComment">&lt;!-- The required file name is defined --&gt;</SPAN> <BR/>
          &nbsp; &nbsp; &nbsp; &lt;Value name="<SPAN class="exampleEmph">defined</SPAN>"/&gt; <BR/>
          <BR/>
          &nbsp; &nbsp; &nbsp; <SPAN class="exampleComment">&lt;!-- The required file name is missing -- an error --&gt;</SPAN> <BR/>
          &nbsp; &nbsp; &nbsp; &lt;Value name="<SPAN class="exampleEmph">missing</SPAN>" <B>failure="true"</B>/&gt; <BR/>
          &nbsp; &nbsp; ... <BR/>
          &nbsp; &lt;/Input&gt; <BR/>
          &nbsp; ... <BR/>
          &lt;/Function&gt; <BR/>
        </DIV>
      </P>

      <P>
        That's it? Your only choices for the file name are "missing" or not? Good question! What's happening
        here is a very important part of input space modeling. It would be silly to list every possible
        file name as a <SPAN class="code">Value</SPAN> here.  Why? Because it just doesn't matter. At least for
        this particular function, the letters and format of the file name have no bearing on the
        behavior of the function. Instead, what's needed is a <U>model</U> of the value domain for this variable that
        characterizes the <U>types</U> of values that are significant to the test. This is a well-known test design
        technique known as <A href="http://en.wikipedia.org/wiki/Equivalence_partitioning">equivalence class
        partitioning</A>. You use each <SPAN class="code">Value</SPAN> element to identify a <U>class</U> of
        values. By definition, all specific values in this class are test-equivalent. We don't need to test them all &mdash; 
        any one of them will do.
      </P>

      <P>
        In the case of the <SPAN class="code">fileName</SPAN> variable, we've decided that the significance of
        file name itself is whether it is present or not, and we've chosen to identify those two variations as
        "defined" and "missing".  But the name you use to identify each <SPAN class="code">Value</SPAN> class is entirely up to you
        &mdash; it is part of the input model you design to describe your tests and it appears in the test case
        definitions that Tcases generates, to guide your test implementation.
      </P>

      <H3><A name="varSets">Defining Variable Sets</A></H3>
      <P>
        It's common to find that a single logical input actually has lots of different characteristics, each of
        which creates a different "dimension of variation" in the input space. For example, consider the file
        that is searched by the <SPAN class="code">find</SPAN> command. Does it even exist? Maybe yes, maybe no
        &mdash; that's one dimension of variation that the tests must cover. And what about its contents? Of
        course, you'd like to test the case where the file contains lines that match the pattern, as well the
        case where there are no matches. So, that's another dimension of variation. The spec says that each
        matching line is printed exactly once, even when it contain multiple matches. Wouldn't you want to test
        a file that has lines with different numbers of matches? Well, there's yet another dimension of
        variation. One file &mdash; so many dimensions!
      </P>

      <P>
        You can model this complex sort of input as a "variable set", using a <SPAN class="code">VarSet</SPAN>
        element.  With a <SPAN class="code">VarSet</SPAN>, you can describe a single logical input as a set of
        multiple <SPAN class="code">Var</SPAN> definitions.  A <SPAN class="code">VarSet</SPAN> can even
        contain another <SPAN class="code">VarSet</SPAN>, creating a hierarchy of logical inputs that can be
        extended to any number of levels.
      </P>

      <P>
        For example, the single <SPAN class="code">file</SPAN> input to the <SPAN class="code">find</SPAN> command
        can modeled by the following <A name="exampleEnv">variable set definition</A>.

        <DIV class="exampleDoc">
          &lt;Function name="find"&gt; <BR/>
          &nbsp; ... <BR/>
          &nbsp; &lt;Input type="env"&gt; <BR/>
          &nbsp; &nbsp; &lt;VarSet name="<SPAN class="exampleEmph">file</SPAN>"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; <SPAN class="exampleComment">&lt;!-- Does the file exist? --&gt;</SPAN> <BR/>
          &nbsp; &nbsp; &nbsp; &lt;Var name="<SPAN class="exampleEmph">exists</SPAN>"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="yes"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="no" failure="true"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;/Var&gt; <BR/>
          &nbsp; &nbsp; &nbsp; <SPAN class="exampleComment">&lt;!-- Does the file contain... --&gt;</SPAN> <BR/>
          &nbsp; &nbsp; &nbsp; &lt;VarSet name="<SPAN class="exampleEmph">contents</SPAN>"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="exampleComment">&lt;!-- ... any lines longer that the pattern? --&gt;</SPAN> <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="<SPAN class="exampleEmph">linesLongerThanPattern</SPAN>"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="one"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="many"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="none" failure="true"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;/Var&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="exampleComment">&lt;!-- ... any matching lines? --&gt;</SPAN> <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="<SPAN class="exampleEmph">patterns</SPAN>"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="none"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="one"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="many"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;/Var&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="exampleComment">&lt;!-- ... multiple matches in a line? --&gt;</SPAN> <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="<SPAN class="exampleEmph">patternsInLine</SPAN>"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="one"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="many"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;/Var&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;/VarSet&gt; <BR/>
          &nbsp; &nbsp; &lt;/VarSet&gt; <BR/>
          &nbsp; &lt;/Input&gt; <BR/>
          &nbsp; ... <BR/>
          &lt;/Function&gt; <BR/>
        </DIV>
      </P>

      <P>
        Isn't this hierarchy really just the same as four <SPAN class="code">Var</SPAN> elements, something like the following?

        <DIV class="exampleDoc">
          &lt;Var name="file.exists"&gt; <BR/>
          ... <BR/>
          &lt;Var name="file.contents.linesLongerThanPattern"&gt; <BR/>
          ... <BR/>
          &lt;Var name="file.contents.patterns"&gt; <BR/>
          ... <BR/>
          &lt;Var name="file.contents.patternsInLine"&gt; <BR/>
          ... <BR/>
        </DIV>
      </P>

      <P>
        Yes, and when generating test cases, that's essentially how Tcases handles it. But defining a complex
        input as a <SPAN class="code">VarSet</SPAN> makes the input model simpler to create, read, and maintain. Also,
        it allows you to apply constraints to an entire tree of variables at once, at you'll see in the next section.
      </P>

      <H3><A name="constraints">Defining Constraints: Properties and Conditions</A></H3>
      <P>
        We've seen how to define the value choices for all of the input variables of each function-under-test,
        including complex input variables with multiple dimensions. That's enough for us to complete a 
        system input definition for the <SPAN class="code">find</SPAN> command that looks something like the following.

        <DIV class="exampleDoc">
          &lt;Function name="find"&gt; <BR/>
          &nbsp; &lt;Input type="arg"&gt; <BR/>
          &nbsp; &nbsp; &lt;VarSet name="pattern"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;Var name="size"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="empty"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="singleChar"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="manyChars"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;/Var&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;Var name="quoted"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="yes"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="no"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="unterminated" failure="true"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;/Var&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;Var name="blanks"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="none"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="one"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="many"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;/Var&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;Var name="embeddedQuotes"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="none"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="one"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="many"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;/Var&gt; <BR/>
          &nbsp; &nbsp; &lt;/VarSet&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="fileName"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;Value name="defined"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;Value name="missing" failure="true"/&gt; <BR/>
          &nbsp; &nbsp; &lt;/Var&gt; <BR/>
          &nbsp; &lt;/Input&gt; <BR/>
          &nbsp; &lt;Input type="env"&gt; <BR/>
          &nbsp; &nbsp; &lt;VarSet name="file"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;Var name="exists"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="yes"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="no" failure="true"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;/Var&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;VarSet name="contents"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="linesLongerThanPattern"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="one"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="many"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="none" failure="true"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;/Var&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="patterns"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="none"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="one"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="many"/&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;/Var&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="patternsInLine"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="one"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;Value name="many"/&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;/Var&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;/VarSet&gt; <BR/>
          &nbsp; &nbsp; &lt;/VarSet&gt; <BR/>
          &nbsp; &lt;/Input&gt; <BR/>
          &lt;/Function&gt; <BR/>
        </DIV>
      </P>

      <P>
        When we run Tcases with this input document, we'll get a list of test case definitions like this:

        <DIV class="exampleDoc">
          &lt;TestCases system="Examples"&gt; <BR/>
          &nbsp; &lt;Function name="find"&gt; <BR/>
          &nbsp; &nbsp; &lt;TestCase id="0"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;Input type="arg"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="pattern.size" value="empty"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="pattern.quoted" value="yes"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="pattern.blanks" value="none"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="pattern.embeddedQuotes" value="none"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="fileName" value="defined"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;/Input&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;Input type="env"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="file.exists" value="yes"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="file.contents.linesLongerThanPattern" value="one"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="file.contents.patterns" value="none"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="file.contents.patternsInLine" value="one"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;/Input&gt; <BR/>
          &nbsp; &nbsp; &lt;/TestCase&gt; <BR/>
          <BR/>
          &nbsp; &nbsp; &lt;TestCase id="1"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;Input type="arg"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="pattern.size" value="singleChar"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="pattern.quoted" value="no"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="pattern.blanks" value="one"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="pattern.embeddedQuotes" value="one"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="fileName" value="defined"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;/Input&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;Input type="env"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="file.exists" value="yes"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="file.contents.linesLongerThanPattern" value="many"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="file.contents.patterns" value="one"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;Var name="file.contents.patternsInLine" value="many"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;/Input&gt; <BR/>
          &nbsp; &nbsp; &lt;/TestCase&gt; <BR/>
          &nbsp; &nbsp; ... <BR/>
          &nbsp; &lt;/Function&gt; <BR/>
          &lt;/TestCases&gt; <BR/>
        </DIV>
      </P>

      <P>
        But wait up a second &mdash; something doesn't look right here. Take a closer look at test case 0 below. It's telling us
        to try a test case using a file that contains no instances of the test pattern. Oh, and at the same time, the file
        should contain a line that has one match for the test pattern. That seems sort of ... impossible.

        <DIV class="exampleDoc">
          &lt;TestCase id="0"&gt; <BR/>
          &nbsp; &lt;Input type="arg"&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="pattern.size" value="empty"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="pattern.quoted" value="yes"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="pattern.blanks" value="none"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="pattern.embeddedQuotes" value="none"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="fileName" value="defined"/&gt; <BR/>
          &nbsp; &lt;/Input&gt; <BR/>
          &nbsp; &lt;Input type="env"&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="file.exists" value="yes"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="file.contents.linesLongerThanPattern" value="one"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="<SPAN class="exampleError">file.contents.patterns</SPAN>" value="<SPAN class="exampleError">none</SPAN>"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="<SPAN class="exampleError">file.contents.patternsInLine</SPAN>" value="<SPAN class="exampleError">one</SPAN>"/&gt; <BR/>
          &nbsp; &lt;/Input&gt; <BR/>
          &lt;/TestCase&gt; <BR/>
        </DIV>
      </P>
      
      <P>
        And look at test case 1 below. It looks equally problematic. For this test case, the pattern should be
        a single character. And the pattern should contain one blank. <U>And</U> the pattern should contain one
        embedded quote character! No way!

        <DIV class="exampleDoc">
          &lt;TestCase id="1"&gt; <BR/>
          &nbsp; &lt;Input type="arg"&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="<SPAN class="exampleError">pattern.size</SPAN>" value="<SPAN class="exampleError">singleChar</SPAN>"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="pattern.quoted" value="no"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="<SPAN class="exampleError">pattern.blanks</SPAN>" value="<SPAN class="exampleError">one</SPAN>"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="<SPAN class="exampleError">pattern.embeddedQuotes</SPAN>" value="<SPAN class="exampleError">one</SPAN>"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="fileName" value="defined"/&gt; <BR/>
          &nbsp; &lt;/Input&gt; <BR/>
          &nbsp; &lt;Input type="env"&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="file.exists" value="yes"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="file.contents.linesLongerThanPattern" value="many"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="file.contents.patterns" value="one"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="file.contents.patternsInLine" value="many"/&gt; <BR/>
          &nbsp; &lt;/Input&gt; <BR/>
          &lt;/TestCase&gt; <BR/>
        </DIV>
      </P>
      
      <P>
        What's happening here? Clearly, some of the "dimensions of variation" described by these <SPAN class="code">Var</SPAN> definitions
        are not entirely independent of each other. Instead, there are relationships among these variables that <EM>constrain</EM> which
        combinations of values are feasible. We need a way to define those relationships so that infeasible combinations can be excluded from
        our test cases. And that's where <EM>properties</EM> and <EM>conditions</EM> come into play.
      </P>

      <H4><A name="properties">Value properties</A></H4>
      <P>
        Any <SPAN class="code">Value</SPAN> definition can declare a <SPAN class="code">property</SPAN> list that
        specifies one or more "properties" for this value. For example:

        <DIV class="exampleDoc">
          &lt;VarSet name="pattern"&gt; <BR/>
          &nbsp; &lt;Var name="size"&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="empty" <SPAN class="exampleEmph">property="empty"</SPAN>/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="singleChar" <SPAN class="exampleEmph">property="singleChar"</SPAN>/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="manyChars"/&gt; <BR/>
          &nbsp; &lt;/Var&gt; <BR/>
          &nbsp; &lt;Var name="quoted"&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="yes" <SPAN class="exampleEmph">property="quoted"</SPAN>/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="no"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="unterminated" failure="true"/&gt; <BR/>
          &nbsp; &lt;/Var&gt; <BR/>
          &nbsp; &lt;Var name="blanks"&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="none"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="one"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="many"/&gt; <BR/>
          &nbsp; &lt;/Var&gt; <BR/>
          &nbsp; &lt;Var name="embeddedQuotes"&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="none"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="one"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="many"/&gt; <BR/>
          &nbsp; &lt;/Var&gt; <BR/>
          &lt;/VarSet&gt; <BR/>
        </DIV>
      </P>

      <P>
        A <SPAN class="code">property</SPAN> list is a comma-separated list of identifiers, each of which defines a "property" for this value.
        A property is just a name that you invent for yourself to identify an important characteristic of this value. The concept is that 
        when this value is included in a test case, it contributes all of its properties &mdash; these now become properties of the test case itself.
        That makes it possible for us to later define "conditions" on which properties a test case must (or must not!) have for certain values
        to be included.
      </P>

      <P>
        For example, the definition above for the <SPAN class="code">pattern.size</SPAN> variable says that
        when we choose the value <SPAN class="code">empty</SPAN> for a test case, the test case acquires a
        property named <SPAN class="code">empty</SPAN>.  But if we choose the
        value <SPAN class="code">singleChar</SPAN>, the test case acquires a different property
        named <SPAN class="code">singleChar</SPAN>. And if we choose the
        value <SPAN class="code">manyChars</SPAN>, no new properties are added to the test case. Note that the
        correspondence between these particular names of the values and properties is not exactly accidental
        &mdash; it helps us understand what these elements mean &mdash; but it has no special significance. We
        could have named any of them differently if we wanted to.
      </P>

      <H4><A name="valueConditions">Value conditions</A></H4>
      <P>
        We can define the conditions required for a <SPAN class="code">Value</SPAN> to be included in a test case using the
        <SPAN class="code">when</SPAN> and <SPAN class="code">whenNot</SPAN> attributes. Each of these defines
        a comma-separated list of property identifiers. Adding a <SPAN class="code">when</SPAN> list means "for
        this value to be included in a test case, the test case must have <U>all</U> of these
        properties". Similarly, a <SPAN class="code">whenNot</SPAN> list means "for this value to be included
        in a test case, the test case must <U>not</U> have <U>any</U> of these properties".
      </P>

      <P>
        For example, consider the conditions we can define for the various characteristics of the <SPAN class="code">pattern</SPAN>
        input.

        <DIV class="exampleDoc">
          &lt;VarSet name="pattern"&gt; <BR/>
          &nbsp; &lt;Var name="size"&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="empty" property="empty"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="singleChar" property="singleChar"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="manyChars"/&gt; <BR/>
          &nbsp; &lt;/Var&gt; <BR/>
          &nbsp; &lt;Var name="quoted"&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="yes" property="quoted"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="no" <SPAN class="exampleEmph">whenNot="empty"</SPAN>/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="unterminated" failure="true"/&gt; <BR/>
          &nbsp; &lt;/Var&gt; <BR/>
          &nbsp; &lt;Var name="blanks"&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="none"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="one" <SPAN class="exampleEmph">when="quoted, singleChar"</SPAN>/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="many" <SPAN class="exampleEmph">when="quoted"</SPAN> <SPAN class="exampleEmph">whenNot="singleChar"</SPAN>/&gt; <BR/>
          &nbsp; &lt;/Var&gt; <BR/>
          &nbsp; &lt;Var name="embeddedQuotes"&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="none"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="one"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="many"/&gt; <BR/>
          &nbsp; &lt;/Var&gt; <BR/>
          &lt;/VarSet&gt; <BR/>
        </DIV>
      </P>

      <P>
        This defines a <EM>constraint</EM> on the <SPAN class="code">pattern.quoted</SPAN> variable. We want to
        have a test case in which the value for this value is <SPAN class="code">no</SPAN>, i.e. the pattern
        string is not quoted. But in this case, the <SPAN class="code">pattern.size</SPAN> cannot
        be <SPAN class="code">empty</SPAN>. Because that combination doesn't make sense, we want to exclude it from the test cases
        generated by Tcases.
      </P>

      <P>
        Similarly, we define a constraint on the <SPAN class="code">pattern.blanks</SPAN> variable, which specifies how many blanks
        should be in the pattern string. We want a test case in which the value is <SPAN class="code">many</SPAN>. But in such 
        a test case, the pattern must be quoted (otherwise, a blank is not possible) and it must <U>not</U> be a single character
        (which would contradict the requirement for multiple blanks).
      </P>

      <P>
        This also defines another constraint on any test case in which the value of <SPAN class="code">pattern.blanks</SPAN> is
        <SPAN class="code">one</SPAN>. In such a test case, of course, the pattern must be quoted. And we've declared also
        that the pattern size must be a single character. But why? That doesn't seem strictly necessary. What's wrong with
        a pattern that has multiple characters and only one blank? Well, nothing &mdash; that's a perfectly good combination.
        But isn't a pattern that is exactly one blank character a more <U>interesting</U> test case? Isn't that a case that could expose
        a certain kind of defect in the pattern matching logic? And isn't the case of many-chars-one-blank unlikely to expose
        any defects not visible in the many-chars-many-blanks case? This demonstrates another way for a smart tester to use properties and conditions:
        to steer toward test cases with more potent combinations and away from combinations that add little defect-fighting power.
      </P>

      <P>
        It's important to note that there are no conditions attached to choosing a value of <SPAN class="code">none</SPAN> for
        <SPAN class="code">pattern.blanks</SPAN>. A test case can use this value in combination with any
        others. And that's a good thing.  We want to model the reality of the input space for the function,
        without eliminating any test cases that are actually feasible. Otherwise, our tests will have a blind
        spot that could allow defects to slip by undetected. Rule of thumb: Use conditions sparingly and only when necessary
        to avoid infeasible or unproductive test cases.
      </P>

      <H4><A name="varConditions">Variable conditions</A></H4>
      <P>
        You may find that, under certain conditions, an input variable becomes irrelevant. It doesn't matter
        which value you choose &mdash; none of them make a difference in function behavior. It's easy to model
        this situation &mdash; just define a condition on the <SPAN class="code">Var</SPAN> definition itself.
      </P>

      <P>
        For example, when we're testing the <SPAN class="code">find</SPAN> command, we want to try all of the
        values defined for every dimension of the <SPAN class="code">pattern</SPAN> variable set. But, in the
        case when the pattern string is empty, the question of how many blanks it contains is pointless.  In
        this case, the <SPAN class="code">pattern.blanks</SPAN> variable is irrelevant. Similarly, when we test
        a pattern string that is only one character, the <SPAN class="code">pattern.embeddedQuotes</SPAN>
        variable is meaningless. We can capture these facts about the input space by adding <SPAN class="code">Var</SPAN>
        constraints, as shown below.

        <DIV class="exampleDoc">
          &lt;<SPAN class="exampleEmph">VarSet name="pattern" when="fileExists"</SPAN>&gt; <BR/>
          &nbsp; &lt;Var name="size"&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="empty" property="empty"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="singleChar" property="singleChar"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="manyChars"/&gt; <BR/>
          &nbsp; &lt;/Var&gt; <BR/>
          &nbsp; &lt;Var name="quoted"&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="yes" property="quoted"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="no" whenNot="empty"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="unterminated" failure="true"/&gt; <BR/>
          &nbsp; &lt;/Var&gt; <BR/>
          &nbsp; &lt;<SPAN class="exampleEmph">Var name="blanks" whenNot="empty"</SPAN>&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="none"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="one" when="quoted, singleChar"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="many" when="quoted" whenNot="singleChar"/&gt; <BR/>
          &nbsp; &lt;/Var&gt; <BR/>
          &nbsp; &lt;<SPAN class="exampleEmph">Var name="embeddedQuotes" whenNot="empty, singleChar"</SPAN>&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="none"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="one"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="many"/&gt; <BR/>
          &nbsp; &lt;/Var&gt; <BR/>
          &lt;/VarSet&gt; <BR/>
        </DIV>
      </P>

      <P>
        You can define variable constraints at any level of a variable set hierarchy. For example, you can see in the example above
        that a constraint is defined for the entire <SPAN class="code">pattern</SPAN> variable set. This constraint models the
        fact that the pattern is irrelevant when the file specified to search doesn't even exist.
      </P>

      <P>
        How does a variable constraint affect the test cases generated by Tcases? In a test case where a
        variable is irrelevant, it is assigned the value "NA", meaning "not applicable". For example, test case
        0 belows shows how testing an empty pattern causes <SPAN class="code">pattern.blanks</SPAN>
        and <SPAN class="code">pattern.embeddedQuotes</SPAN> to be irrelevant. Similarly, test case 8 shows how testing
        with a non-existent file makes nearly every other variable irrelevant.

        <DIV class="exampleDoc">
          &lt;TestCase id="0"&gt; <BR/>
          &nbsp; &lt;Input type="arg"&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="pattern.size" value="empty"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="pattern.quoted" value="yes"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="pattern.blanks" <SPAN class="exampleEmph">value="NA"</SPAN>/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="pattern.embeddedQuotes" <SPAN class="exampleEmph">value="NA"</SPAN>/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="fileName" value="defined"/&gt; <BR/>
          &nbsp; &lt;/Input&gt; <BR/>
          &nbsp; &lt;Input type="env"&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="file.exists" value="yes"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="file.contents.linesLongerThanPattern" value="one"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="file.contents.patterns" <SPAN class="exampleEmph">value="NA"</SPAN>/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="file.contents.patternsInLine" <SPAN class="exampleEmph">value="NA"</SPAN>/&gt; <BR/>
          &nbsp; &lt;/Input&gt; <BR/>
          &lt;/TestCase&gt; <BR/>
          ... <BR/>
          &lt;TestCase id="8" failure="true"&gt; <BR/>
          &nbsp; &lt;Input type="arg"&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="pattern.size" <SPAN class="exampleEmph">value="NA"</SPAN>/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="pattern.quoted" <SPAN class="exampleEmph">value="NA"</SPAN>/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="pattern.blanks" <SPAN class="exampleEmph">value="NA"</SPAN>/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="pattern.embeddedQuotes" <SPAN class="exampleEmph">value="NA"</SPAN>/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="fileName" value="defined"/&gt; <BR/>
          &nbsp; &lt;/Input&gt; <BR/>
          &nbsp; &lt;Input type="env"&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="file.exists" value="no" failure="true"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="file.contents.linesLongerThanPattern" <SPAN class="exampleEmph">value="NA"</SPAN>/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="file.contents.patterns" <SPAN class="exampleEmph">value="NA"</SPAN>/&gt; <BR/>
          &nbsp; &nbsp; &lt;Var name="file.contents.patternsInLine" <SPAN class="exampleEmph">value="NA"</SPAN>/&gt; <BR/>
          &nbsp; &lt;/Input&gt; <BR/>
          &lt;/TestCase&gt; <BR/>
        </DIV>
      </P>

      <H4><A name="complexConditions">Complex conditions</A></H4>
      <P>
        The <SPAN class="code">when</SPAN> and <SPAN class="code">whenNot</SPAN> attributes are sufficient to express the most common
        constraints on <SPAN class="code">Var</SPAN> and <SPAN class="code">Value</SPAN> definitions. But what if the condition you need is
        more complicated? For example, what about a <SPAN class="code">Value</SPAN> that can be included only if a test case has either
        property X <U>or</U> property Y? For such situations, you can define conditions using a <SPAN class="code">When</SPAN> element.
        A <SPAN class="code">When</SPAN> element can appear as a subelement of any definition that allows a condition: <SPAN class="code">Value</SPAN>,
        <SPAN class="code">Var</SPAN>, or <SPAN class="code">VarSet</SPAN>.
      </P>

      <P>
        For example, the condition for a test case to include a pattern with many blank characters can be expressed with a <SPAN class="code">When</SPAN>
        element like this:

        <DIV class="exampleDoc">
          &lt;VarSet name="pattern" when="fileExists"&gt; <BR/>
          &nbsp; ...  <BR/>
          &nbsp; &lt;Var name="blanks" whenNot="empty"&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="none"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="one" when="quoted, singleChar"/&gt; <BR/>
          &nbsp; &nbsp; &lt;Value name="many"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; <SPAN class="exampleEmph">&lt;When&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="exampleComment">&lt;!-- All of the condition below are true... --&gt;</SPAN> <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;AllOf&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="exampleComment">&lt;!-- ... all of the following properties are present... --&gt;</SPAN> <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;AllOf property="quoted"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN class="exampleComment">&lt;!-- ... and none of&nbsp; the following properties are present. --&gt;</SPAN> <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;Not property="singleChar"/&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &nbsp; &lt;/AllOf&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;/When&gt;</SPAN> <BR/>
          &nbsp; &nbsp; &lt;/Value&gt; <BR/>
          &nbsp; &lt;/Var&gt; <BR/>
          &nbsp; ... <BR/>
          &lt;/VarSet&gt; <BR/>
        </DIV>
      </P>

      <P>
        A <SPAN class="code">When</SPAN> element contains a single subelement that defines a boolean expression. The boolean expressions are:
        
        <UL>
          <LI> <SPAN class="code">AllOf</SPAN>: a logical "AND" expression
          </LI><P/>
          <LI> <SPAN class="code">AnyOf</SPAN>: a logical "OR" expression
          </LI><P/>
          <LI> <SPAN class="code">Not</SPAN>: a logical negation expression
          </LI><P/>
        </UL>
      </P>

      <P>
        All of these elements have a similar structure. They can have an optional <SPAN class="code">property</SPAN> list, which specifies the
        properties that are subject to this expression. Also, they can contain any number of additional boolean expressions as subelements.
        For example:

        <DIV class="exampleDoc">
          &lt;When&gt; <BR/>
          &nbsp; &lt;Not property="A"&gt; <BR/>
          &nbsp; &nbsp; &lt;AnyOf property="B"&gt; <BR/>
          &nbsp; &nbsp; &nbsp; &lt;AllOf property="C, D"/&gt; <BR/>
          &nbsp; &nbsp; &lt;/AnyOf&gt; <BR/>
          &nbsp; &lt;/Not&gt; <BR/>
          &lt;/When&gt; <BR/>
        </DIV>
      </P>

      <P>
        This <SPAN class="code">When</SPAN> expression is equivalent to the following boolean expression in Java.

        <DIV class="exampleDoc">
          !A && !(B || (C && D))
        </DIV>
      </P>

      <P>
        The <SPAN class="code">when</SPAN> and <SPAN class="code">whenNot</SPAN> attributes are shorthand for the equivalent
        <SPAN class="code">When</SPAN> expression, and these alternatives are mutually exclusive. If you use either of these attributes, you
        can't specify a <SPAN class="code">When</SPAN> element in the same definition and vice versa.
      </P>

      <H2><A name="coverage">Defining Input Coverage</A></H2>

      <H2><A name="control">Controlling Test Cases</A></H2>

      <H2><A name="transform">Transforming Test Cases</A></H2>

      <H3><A name="junit">Creating JUnit Tests</A></H3>
      <P>
      </P>

    </DIV>

  </BODY>
</HTML>
